<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>尘白禁区信源研析</title>
  <script src="https://cdn.bootcdn.net/ajax/libs/vue/3.2.47/vue.global.prod.min.js"></script>
  <script src="./calc.js"></script>
</head>

<body>
  原作者：<a href="https://space.bilibili.com/277401945" target="_blank">Bilibili 方形的块状代码</a>
  <div id="app">
    <p>行数：<input type="text" v-model="row" /></p>
    <p>列数：<input type="text" v-model="col" /></p>
    <input type="button" value="确定" @click="confirmBoard">
    <p>红色表示需要摆放的格子，白色表示这里没有格子，点击切换</p>
    <div v-for="(r, i) in board" style="height: 32px;">
      <div
        class="box"
        v-for="(c, j) in r"
        @click="tuneBox(i, j)"
        :style="{ 'background-color': c === 0 ? 'white' : 'red' }"
      ></div>
    </div>
    <div v-if="board.length" style="margin-top: 0px;">
        <div style="width:fit-content;">
          <table>
            <tr>
              <th></th>
              <th>
                <div style="margin-left: 0px;">
                  必选
                </div>
              </th>
              <th>
                <div style="margin-left: 0px;">
                  回收
                </div>
              </th>
              <th>
                <div style="margin-left: 0px;">
                  回收个数
                </div>
              </th>
              <th>
                <div style="margin-left: 0px;">
                  取消回收
                </div>
              </th>
            </tr>
            <tr v-for="(b, i) in num">
              <td>
                方块{{ i + 1 }}个数：
                <div v-if="i+1 === 9" style="display: inline-block;">
                  {{ num[i] + recycledComponents.length}} = 
                      <input style="width: 100px;"  type="text" v-model.number="num[i]" />
                      + {{ recycledComponents.length }}
                </div>
                <div v-else style="display: inline-block;">
                  
                      <input type="text" v-model.number="num[i]" />
  

                </div>
              </td>
              <td style=" zoom: 100%; vertical-align: middle; margin-top: 80px; text-align: center;">
                <input type="checkbox" 
                  style="text-align: left; vertical-align: middle; margin-top: 5px;"
                  v-model="selected[i]" 
                  :title="'信源 ' + (i+1) + ' 必选'"
                  @click="select(i)"/>
              </td>
              <td>
                <Button type="" @click="recycle(i)">🗑️</Button>
              </td>
              <td style="vertical-align: middle; text-align: center;">
                {{ recycledNum[i] }}
              </td>
              <td style="text-align: center;">
                <Button type="" @click="cancelRecycle(i)">🗑️-1</Button>
              </td>
            </tr>
          </table>
          
          <div 
          style="margin-top: 5px; 
          margin-bottom: 5px; 
          margin-right: 10px; 
          border: dashed 2px; 
          border-radius: 10px; 
          padding: 5px;
          ">
            <div style="font-size: medium;">
              方块9个数=用户输入 {{ num[8] }} + 回收得到 {{ recycledComponents.length }} <br>
            </div>
            <div style="margin-top: 7px; margin-bottom: 5px;">
              回收的方块9构成：
            </div>
            <div v-for="(v, i) in recycledComponents">
              <div style="display:inline-block;" v-for="(v2, j) in recycledComponents[i]">
                方块 {{v2}},&nbsp; 
              </div>
              <br>
              <hr />
            </div>
          </div>

          <div
          style="margin-top: 5px; 
          margin-bottom: 5px; 
          margin-right: 10px; 
          border: dashed 2px; 
          border-radius: 10px; 
          padding: 5px;
          ">
            <p>【2023-09-24注】目前对于方块 10 和 11 的支持仅经过了简单测试</p>
            <p>如果遇到关于方块 10 和 11 的 bug 可以带上出错的情况给我的 <a href="https://github.com/halozhy/cbjq">GitHub 分支仓库</a> 提 Issue</p>
            <p>（或者在 <a href="https://www.bilibili.com/video/BV1hp4y1j75k/">BV1hp4y1j75k</a> 这个视频下面评论区带上出错的情况留言）</p>
          </div>
         
          <div>
            <input type="button" value="计算完美方案" @click="calc">
            <input type="button" style="margin-left: 10px;" value="一键回收并计算" @click="calcFull">
            <input type="button" style="margin-right: 10px; float: right;" value="撤销所有回收" @click="resetRecycle">
          </div>
        </div>

      
    </div>
    <div v-if="res !== false">
      <p>方案数：{{ res.length }}</p>
      <p>方案数(filterd)：{{ selectResult.length }}/{{ res.length }}</p>
    </div>
    <div v-if="res.length">
      <p>当前展示方案：{{ now + 1 }} / {{ res.length }}</p>
      <p>当前展示方案(filterd)：{{ now + 1 }} / {{ selectResult.length }}</p>
      <input type="button" value="<-" @click="now -= (now > 0)">
      <input type="button" value="->" @click="now += (now + 1 < selectResult.length)">
      <div v-for="(r, i) in sol" style="height: 32px;">
        <div
          class="box"
          v-for="(c, j) in r"
          :style="{ 'background-color': color[c] }"
        >{{ c }}</div>
      </div>
    </div>
  </div>
  <script>
    const { createApp } = Vue
    createApp({
      data() {
        return {
          row: 5,
          col: 6,
          board: [],
          num: new Array(11).fill(0),
          // num: [1,1,1,2,2,2,2,1,0],
          // num: [6,1,1,2,2,2,2,1,0], 
          // num: [2,2,2,2,2,0,0,0,0], 
          recycledNum: new Array(11).fill(0),
          recycledComponents: new Array(0),
          selected: new Array(11).fill(false),
          res: false,
          selectResult: false,
          now: 0,
          color: ['white', '#75C0FF', '#3B66CF', '#78ACC5', '#C8FAFD', '#FDFF00', '#4BFF00', '#FF9800', '#B9B24B', '#FF00AE', '#FF00EE', '#acb7d5']
        }
      },
      methods: {
        confirmBoard() {
          const row = Number(this.row)
          const col = Number(this.col)
          this.board = new Array(row)
          for (let i = 0; i < row; ++i) {
            const r = new Array(col).fill(-1)
            this.board[i] = r
          }
        },
        tuneBox(x, y) {
          if (this.board[x][y] === -1) {
            this.board[x][y] = 0
          } else {
            this.board[x][y] = -1
          }
        },
        calc() {
          let num = Object.assign([], this.num)
          num[8] = this.num[8] + this.recycledComponents.length
          this.res = Solve(this.board, num)
          this.now = 0
          this.filter();
        },
        filter(requiredInfoIds) {
          // console.log('in filter');
          if(!this.res){
            return;
          }

          if(!requiredInfoIds){
            requiredInfoIds = this.selected.map((v,i)=>v?i+1:-1).filter(v => v !== -1);
          } 
          // console.log("filter array:",requiredInfoIds);
          if(requiredInfoIds.length == 0){
            this.selectResult = this.res;
            return;
          }
          this.selectResult = this.res.filter(function(result){
            let temp = [].concat(...result);
            let cnt = 0;
            for(let i=0;i<requiredInfoIds.length;++i){
              if(!temp.includes(requiredInfoIds[i])){
                return false;
              }
            }
            return true;
          });
        },
        select(index) {
          // console.log('select');
          let requiredInfoIds = new Array();
          this.selected.forEach((isSelect, i) => {
            if(isSelect && i!=index || !isSelect && i==index){
              requiredInfoIds.push(i+1);
            }
          });
          this.filter(requiredInfoIds);
        },

        // 返回能够回收到的最多的9号断片的回收方案
        find9Max(recycledNum) {
          // 其实就是找出所有的回收方案，之后从里面找一个最长的
          let allPathArr = this.find9All(recycledNum);
          let max = 0
          let maxPathArr = [];
          allPathArr.forEach(onePath => {
            if (onePath.length > max) {
              max = onePath.length;
              maxPathArr = onePath;
            }
          });
          return maxPathArr; 
        },

        // 返回所有9号断片的回收方案
        find9All(recycledNum) {
          let num = Object.assign([], recycledNum);
          let allPathArr = [];

          // 计算组合数 C(9,5) 结果应该是固定的126种可能
          let chooseResult = choose(Array.from({length:9}, (v,k) => k), 5);
          // https://juejin.cn/post/6959102042279247909
          function choose(arr, size) {
            var allResult = [];
            (function (arr, size, result) {
                var arrLen = arr.length;
                if (size > arrLen) {
                    return;
                }
                if (size == arrLen) {
                    allResult.push([].concat(result, arr))
                } else {
                    for (var i = 0; i < arrLen; i++) {
                        var newResult = [].concat(result);
                        newResult.push(arr[i]);

                        if (size == 1) {
                            allResult.push(newResult);
                        } else {
                            var newArr = [].concat(arr);
                            newArr.splice(0, i + 1);
                            arguments.callee(newArr, size - 1, newResult);
                        }
                    }
                }
            })(arr, size, []);
            return allResult;
          }
          
          // 递归查找  
          recursionFind(num, [], 0);

          /**
           * 进行递归凑数查找9号碎片的函数
           * @param {*} nowRecycleNum 可回收的num数组
           * @param {*} pathArr 记录了回收结果的数组，也相当于是递归路径
           * @param {*} layer 递归层数
           */
          function recursionFind(nowRecycleNum, pathArr, layer) {
            layer++;
            let okResultList = [];
            for (let i = 0; i < chooseResult.length; i++) {
              const result = chooseResult[i];
              // console.log(result);
              let flag = true;
              for (let j = 0; j < result.length; j++) {
                const index = result[j];
                if (nowRecycleNum[index] <= 0 ) {
                  // console.log('存在0，无法回收');
                  flag = false;
                  break;
                }
              }
              if (flag) {
                // 记录下来能回收的可能性
                okResultList.push(result);
                // break;
              }
            }
            // console.log('这层的所有方案数量', layer, okResultList.length);
            if (okResultList.length == 0) {
              // 这层已经找不到方案了，因此return结束此层递归
              return;
            }
            else {
              // 这层仍有方案，则记录在allPathArr里面
              for (let index = 0; index < okResultList.length; index++) {
                const thisPath = okResultList[index];
                // let newOne = [pathArr , thisPath];
                let newOne = [].concat(pathArr);
                newOne.push(thisPath);
                allPathArr.push(newOne)  
              }
              // console.log(allPathArr);
            }
            // console.log('okResultList', layer, okResultList, pathArr);
            for (let i = 0; i < okResultList.length; i++) {
              const okResult = okResultList[i];
              // 按照方案对nowRecycleNum执行删减
              let nRN = [].concat(nowRecycleNum);
              okResult.forEach(index => {
                nRN[index]--;
              });
              let pa = JSON.parse(JSON.stringify(pathArr));
              pa.push(okResult)
              recursionFind(nRN, pa, layer);
            }
          }
          
          return allPathArr;
        },

        calcFull() {
          // 一键回收并计算
          // 先尝试不回收，直接计算，如果能出结果就不进行回收
          // 如果不能出结果，计算出所有的9号回收方案，依次尝试，直到出结果为止
          // 如果均尝试过了，但没结果，则认为无解
         
          // 先尝试不回收，直接计算，若有结果，直接return结束
          this.calc();
          if (this.selectResult.length > 0 ) {
            return;
          } 
          else {
            // 如果不能直接出结果，计算出所有的9号回收方案
            let allPathArr = this.find9All(this.num);
            // 依次尝试，直到calc计算后有结果为止
            for (let index = 0; index < allPathArr.length; index++) {
              const onePath = allPathArr[index];
              // 按照这个方案进行回收
              for (let j = 0; j < onePath.length; j++) {
                const one9 = onePath[j];
                one9.forEach(index => {
                  // 执行num--和recycle++
                  this.num[index]--;
                  this.recycledNum[index]++;
                });
                // 对界面上的回收区进行更新
                let one9ForView = one9.map((i)=>(i+1));
                this.recycledComponents.push(one9ForView);
              }
              
              // 执行calc计算，看看有没有结果
              this.calc();
              if (this.selectResult.length > 0 ) {
                // 有结果了，return结束
                return;
              } 
              else {
                // 无结果，恢复num，recycleNum，recycledComponents
                for (let j = 0; j < onePath.length; j++) {
                  const one9 = onePath[j];
                  one9.forEach(index => {
                    // 执行num++和recycle--
                    this.num[index]++;
                    this.recycledNum[index]--;
                  });
                }
                this.recycledComponents = [];
              }
            }
          }
        },
        resetRecycle() {
          for (let index = 0; index < this.recycledNum.length; index++) {
            const value = this.recycledNum[index];
            while (this.recycledNum[index] > 0 ){
              this.cancelRecycle(index)
            }
          }
          this.calc()
        },
        recycle(index) {
          if (this.num[index] > 0 ){
            this.num[index] = this.num[index] - 1;
            this.recycledNum[index] = this.recycledNum[index] + 1;
          }
          this.calcAfterRecycle();
        },
        cancelRecycle(index) {
          if (this.recycledNum[index] > 0 ){
            this.num[index] = this.num[index] + 1;
            this.recycledNum[index] = this.recycledNum[index] - 1;
          }
          this.calcAfterRecycle();
        },
        calcAfterRecycle(){
          // 算出回收区中能凑出的最大9号数量方案maxPathArr
          let maxPathArr = this.find9Max(this.recycledNum);
          let max = maxPathArr.length;
          // 制作this.recycledComponents，目的是将各个9号碎片的回收组成显示出来
          this.recycledComponents = [];
          maxPathArr.forEach(path => {
            path = path.map((i)=>(i+1));
            this.recycledComponents.push(path);
          });
        },
        
      },
      computed: {
        sol() {
          return this.selectResult[this.now]
        }
      }
    }).mount('#app')
  </script>
  <style>
    p {
      margin: 4px 0;
    }
    .box {
      display: inline-block;
      box-sizing: border-box;
      width: 32px;
      height: 32px;
      border: 1px black solid;
      cursor: pointer;
    }
  </style>
</body>

</html>